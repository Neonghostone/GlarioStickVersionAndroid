<!DOCTYPE html>
<html lang="en"> 
<head>
<title>Gladiators</title>
<meta content="text/html; charset=UTF-8" http-equiv="content-type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="title" content="Gladiators">
<meta name="description" content="Game">
<button onclick="MoveRight()"> This is a button </button>
<link rel="icon" type="image/png" href="glario.png"> 
<link rel="stylesheet" type="text/css" href="style.css"> 
<link rel="manifest" href="manifest.manifest">
</head>
<body onload="">
<div class="maindiv" id="maindiv">
<div class="canvasdiv" id="canvasdiv">
<canvas class="canvas"id="canvas" width="1280" height="720">
Your web browser does not support canvas.
</canvas>

<button> This is a button for advance right</button>
<button> This is a button for advance left</button>
</div>
</div><!-- maindiv -->

</body>
<script type="text/javascript">

// IMAGES


//Main class for everything
//Task list 
//Lifespan LifeTime and Draw the other enemies
//Draw collision lines for the button technique


//Demonstration images
var ActualUniverse;
var wall=new Image();
var gladiatorTest=new Image();
var TestPlatform=new Image();
//Backround image for all the levels
var BGImage=new Image();
var EnemyCharacterStageOne;
var SpeedOfMainCharacterDebug = 5;



class Universe
{ 

	constructor(name, state, level  ) 
	{
		this.name = name;		
		this.state = state;	
		this.level = level;		
		this.MinLevel = 0;
		this.MaxLevel = 3;
		this.actorsIngame = [];
		this.MainCharacter = undefined;
		this.MainBiController = undefined;		
		this.bDrawDebug = false;
		this.floatingtexts = [];
		
	} 

	//Side can be up down left or right but for now just left and right
	loadNextLevel(Side)
	{ 
		if( Side == 0 )
		{
			this.level++;
		} 
		if( Side == 1 )
		{
			this.level--;
		}			
	}
	
	InstanceGameplayFloatingText(x, y, floatingtext, textduration, textcolor, textspeed, textlevel, textsize)
	{	
		let LocalSpawnedText;
		
		LocalSpawnedText = new FloatingText(x, y, floatingtext, textduration, textcolor, textspeed, textlevel, textsize);
		
		this.floatingtexts.push(LocalSpawnedText);
	}

}

//Desc: this are textes to symbolize what is going on and to debug 
class FloatingText
{
	
	constructor(x, y, floatingtext, textduration, textcolor, textspeed, textlevel, textsize) 
	{
		
		this.x = x;
		this.y = y;		
		this.floatingtext = floatingtext;
		this.textduration = textduration;
		this.textcolor = textcolor;
		this.textspeed = textspeed; 
		this.textlevel = textlevel; //Level in which the text is at	
		this.textsize = textsize;
		
	}
	
	TextTick(DeltaTime)
	{
		
		
	}
	
	
}

//Desc: This is a class 
class Actor 
{

	constructor(name, x, y, team, 
	mainTexture, InternalTexture, 
	ActorHealth, ActorState, 
	level
	) 
	{
		//Other variables
		this.AirActualSpeed = 2;
		//contruct variables
		this.name = name;
		this.x = x; 
		this.y = y;
		this.team = team; //Team 1 Players/hero  Team 2 Enemies
		
		//Textures
		this.mainTexture = mainTexture;//"BloodForWebGladiators1.png";
		this.PrepareAttackTexture = "MulliusShieldAndSwordPrepareAttack.png"; //Prepare here
		this.UnleashAttackTexture = "MulliusShieldAndSwordAndSheldJustUnleashedAttack.png";
		this.BlockingTexture = "MulliusShieldProtecting.png";	//WIP	
		
		//Left textrues
		this.IdleTextureLeft = "MulliusShieldAndSwordIdleLeft.png";	
		this.UnleashAttackTextureLeft = "MulliusShieldAndSwordAndSheldJustUnleashedAttackLeft.png";			
		this.UnleashAttackTexturePrepareLeft = "MulliusShieldAndSwordPrepareAttackLeft.png";
		this.BlockingTextureLeft = "MulliusShieldProtectingLeft.png"	//WIP	
		
		
		this.InternalTexture=new Image();
		this.InternalTexture.setAttribute("src", this.mainTexture);  
		

		//Collision and drawing
		this.ActorHealth = 100; 	
		this.ActorState = "Idle"; //"normal" is alive, "dead" is dead //This is the general state
		this.collisionSizeMinX1 = -125; //the collision size box
		this.collisionSizeMinY1 = -200; //the collision size box
		this.collisionSizeMaxX1 = 125; //the collision size box
		this.collisionSizeMaxY1 = 125; //the collision size box	
		this.DrawSizeX = 256; //the draw size
		this.DrawSizeY = 64; //the draw size	
		this.ClippingImageSizeX = 885.0;
		this.ClippingImageSizeY = 100.0;
		
		
		this.IsJumpingTimer = undefined;
		this.bCanStopJumpNow = false;
		this.bShouldGoDown = true;
		this.IsCollidingWithSomething = false;
		this.jumpSpeed = 4.0;
		this.bMovingLeft = false;
		this.level = level;
		//this.DrawSizeX = DrawSizeX; //the draw size
		//this.DrawSizeY = DrawSizeY; //the draw size
		this.OffensiveState = "Idle"; //always states start with capital letters
		this.HandleOfPrepareMinTime = null;
		this.HandleOfAttackDuration = null;
		this.HandleOfBlockDuration = null;
		this.HandleOfBlockCooldown = null;
		this.MinPrepareAttackDuration = 500;			
		this.AttackDuration = 500;	
		this.bHasPressedAttackButtton = false;
		this.bHasCollision = true;
		this.YOffset = 0.0; //So we set land distance when walking, draws
		this.XOffset = 0.0; //So we set land distance when walking, draws		
		
	} 
	
	//List of states 
	SetState(ActorNewState)
	{
		this.ActorState = ActorNewState;
	}
	
	SetOffensiveState(ActorNewOffensiveState)
	{
		this.OffensiveState = ActorNewOffensiveState;
	}	
	
	ProcessMoveSmooth(newDesiredMovement)
	{
		this.x += newDesiredMovement;
	}
		
	ChangeDirection(NewDirection)
	{

		this.bMovingLeft = NewDirection
		
		if(this.bMovingLeft)
		{			
			if( (this.ActorState == "Idle"|| this.ActorState == "Jumping") && this.HandleOfPrepareMinTime == null && this.HandleOfAttackDuration == null && this.OffensiveState != "PreparingAttack" && this.OffensiveState != "Blocking") 
			{ 
				this.InternalTexture.setAttribute("src", this.IdleTextureLeft); 
			}
			else if( this.HandleOfPrepareMinTime != null ) 
			{ 
				this.InternalTexture.setAttribute("src", this.UnleashAttackTexturePrepareLeft);	
			} 
			else if( this.HandleOfAttackDuration != null ) 
			{
				this.InternalTexture.setAttribute("src", this.UnleashAttackTextureLeft);
			} 
			else if( this.OffensiveState == 'Blocking' ) 
			{
				console.log("FROM Index change direction the state is LEFT");
				this.InternalTexture.setAttribute("src", this.BlockingTextureLeft);
			}				
		
		} 
		else                                                                           
		{
			if((this.ActorState == "Idle"|| this.ActorState == "Jumping"  ) && this.HandleOfPrepareMinTime == null && this.HandleOfAttackDuration == null && this.OffensiveState != "PreparingAttack" && this.OffensiveState != "Blocking" ) 
			{ 
				this.InternalTexture.setAttribute("src", this.mainTexture);	
			} 
			else if( this.HandleOfPrepareMinTime != null ) //Use a sub states of attack later
			{ 
				this.InternalTexture.setAttribute("src", this.PrepareAttackTexture);
			} 
			else if( this.HandleOfAttackDuration != null ) 
			{ 
				this.InternalTexture.setAttribute("src", this.UnleashAttackTexture);
			} 
			else if( this.OffensiveState == 'Blocking'  ) 
			{
				console.log("FROM Index change direction the state is RIGHT");
				this.InternalTexture.setAttribute("src", this.BlockingTexture);
			}			
		}   
		
	}
	
	BeginJump()
	{ 
		let self; 	
	
		self = this;	
		
		if( this.ActorState != "Jumping" ) 
		{

			this.IsJumpingTimer = setInterval(StartedToJump, 250);
			this.bCanStopJumpNow = false;		
			this.jumpSpeed = 4.0;
			this.SetState("Jumping");

			function StartedToJump()
			{
			
				clearTimeout(self.IsJumpingTimer); 	
				self.bCanStopJumpNow = true;
				self.bShouldGoDown = true;

			}

		} 
	}
		

		
	isActorCollidingWithSomething()
	{ 
		let self = this;
		let actorsWhichIsCollidingWith = [];
	
		GetUniverse().actorsIngame.forEach(CheckCollisionForActorsInFunction);
		
		function CheckCollisionForActorsInFunction(value, index, array) 
		{	
		
			if( value != self && value.constructor.name != "Pawn" && value.level == self.level ) 
			{
				if( DoesThisCollide( self.x, self.y, (value.x - value.collisionSizeMinX1/2) + 
				value.collisionSizeMinX1, (value.y - value.collisionSizeMinY1/2) + 
				value.collisionSizeMinY1, (value.x + value.collisionSizeMaxX1 / 2 ) + 
				value.collisionSizeMaxX1, (  value.y + value.collisionSizeMaxY1/2 ) + 
				value.collisionSizeMaxY1 ) ) 
				{
					actorsWhichIsCollidingWith.push(value);
				}
			}
			
		
		}
		 
		return actorsWhichIsCollidingWith;
	}
		
		
	isActorCollidingWithSomethingRightSide()
	{ 
		let self = this;
		let actorsWhichIsCollidingWith = [];
	
		GetUniverse().actorsIngame.forEach(CheckCollisionForActorsInFunction);
		
		function CheckCollisionForActorsInFunction(value, index, array) 
		{	
		
			if( value != self && value.constructor.name != "Pawn" && value.level == self.level) 
			{
				
				if( DoesThisCollide( self.x+25, self.y-20, (value.x - value.collisionSizeMinX1/2) + 
				value.collisionSizeMinX1, (value.y - value.collisionSizeMinY1/2) + 
				value.collisionSizeMinY1, (value.x + value.collisionSizeMaxX1 / 2 ) + 
				value.collisionSizeMaxX1, (value.y + value.collisionSizeMaxY1/2 ) + 
				value.collisionSizeMaxY1 ) ) 
				{
					actorsWhichIsCollidingWith.push(value);
				}
			}
			
		
		}
		 
		return actorsWhichIsCollidingWith;
	}		
		
	
	isActorCollidingWithSomethingLeftSide()
	{ 
		let self = this;
		let actorsWhichIsCollidingWith = [];
	
		GetUniverse().actorsIngame.forEach(CheckCollisionForActorsInFunction);
		
		function CheckCollisionForActorsInFunction(value, index, array) 
		{	

			if( value != self && value.constructor.name != "Pawn" && value.level == self.level) 
			{
				//Previous value
				if( DoesThisCollide( self.x-25, self.y+-20, (value.x - value.collisionSizeMinX1/2) + 
				value.collisionSizeMinX1, (value.y - value.collisionSizeMinY1/2) + 
				value.collisionSizeMinY1, (value.x + value.collisionSizeMaxX1 / 2 ) + 
				value.collisionSizeMaxX1, (value.y + value.collisionSizeMaxY1/2 ) + 
				value.collisionSizeMaxY1 ) ) 
				{
					actorsWhichIsCollidingWith.push(value);
				}
			}
			
		
		}
		 
		return actorsWhichIsCollidingWith;
	}		
		
	
		
	IsAnyActorAsPlatform(pActorsChecking = [])
	{
		let i= 0;

	
		for( i = 0; i < pActorsChecking.length; i++) 
		{ 
			if(  ReturnDirectionActors ( this, pActorsChecking[i] ) < 0 )
			{
				return true;	
			}
		}
		
		return false;
	}
		
	ActorTick(DeltaTime)
	{
		let self; 
		let ArrayOfActorsColliding = [];
		let ArrayOfActorsCollidingRight = [];
		let ArrayOfActorsCollidingLeft = [];
		
		self = this;
		//super.ActorTick(DeltaTime); 
		//this.actorClass="Pawn";
	
	
		if(this.bHasCollision)
		{	
			ArrayOfActorsColliding = this.isActorCollidingWithSomething();
			ArrayOfActorsCollidingRight = this.isActorCollidingWithSomethingRightSide();		
			ArrayOfActorsCollidingLeft = this.isActorCollidingWithSomethingLeftSide();	
		}


		//Check if is in any order
		this.ConsiderIfActorWentOutsideLevelByTick();


		if(this.name == "MulliusMainChar") 
		{
			if( ArrayOfActorsCollidingRight[0] != undefined ) 
			{
				
			}
		}

		if(this.name == "MulliusMainChar") 
		{
			if( ArrayOfActorsCollidingLeft[0] != undefined ) 
			{
				
			}
		}



		if(this.bMoving ) 
		{ 
			if(this.bGoingRight && ArrayOfActorsCollidingRight.length <= 0  ) 
			{
				this.x += SpeedOfMainCharacterDebug;
			} 
			if(!this.bGoingRight && ArrayOfActorsCollidingLeft.length <= 0  )
			{ 
				this.x -= SpeedOfMainCharacterDebug;			
			}
		
		}
		
		if( ArrayOfActorsColliding.length > 0 )
		{											//True up down false TranslateNumToUpOrDown( ReturnDirectionActors ( isActorCollidingWithSomething(), this ) )
			if(this.bCanStopJumpNow == false    )
			{
				
				if(this.IsAnyActorAsPlatform(ArrayOfActorsColliding) == true ) 
					this.AirActualSpeed = 0;
				else
					this.AirActualSpeed = 2.5;
				
			}
			else
			{
			    if( self.ActorState == "Jumping" ) 
				{
					
					this.SetState("Idle");
					this.bCanStopJumpNow = false;
					
				}
			}
		
			
		}
		else
		{

			if(this.bCanStopJumpNow == false )
			{
				this.AirActualSpeed = 2.5;			
			}		
		}
	

	
	
		GetUniverse().actorsIngame.forEach(CheckCollisionForActors);
		
		//Just for debugging purposes see if they are colliding AN DSTOP THE JUMPING
		function CheckCollisionForActors(value, index, array) 
		{
	


			if( value != self && value.constructor.name != "Pawn" && self.constructor.name == "Pawn" ) //Make sure we are
			{					//Dont collide pawn and pawn																		
				if( DoesThisCollide( self.x, self.y, (value.x - value.collisionSizeMinX1/2) + value.collisionSizeMinX1, (value.y - value.collisionSizeMinY1/2) + value.collisionSizeMinY1, (value.x + value.collisionSizeMaxX1 / 2 ) + value.collisionSizeMaxX1, (value.y + value.collisionSizeMaxY1/2 ) + value.collisionSizeMaxY1 ) ) 
				{ 
					

				
				}
				else
				{
				}
			}
			
			
        }	
	
		if(this.constructor.name == "Pawn" && this.ActorState != "Jumping" )
		{
			//if(this.bCanStopJumpNow == false ) 
			//{
				this.y += 1.0 * this.AirActualSpeed;
			//}	
		} 

		if( this.ActorState == "Jumping" ) //Jumping gravity
		{
			this.y -= 1.0 * this.jumpSpeed;
			this.jumpSpeed -= 0.1;

			
			//if( this.AirActualSpeed <= 0 ) 
			//{
			    //this.SetState("Idle");		
			//}
			
			//this.AirActualSpeed = InterpolateNumbers( this.AirActualSpeed , 0.1, 0.0 );	);
		}
		
	
		if( this.PawnController && this.ActorState != "Dead" ) //Valid check here the object exists 
		{
			/* DEPRA FOR NOW
			this.x = InterpolateNumbers( this.x, 0.001, this.PawnController.DesiredLocToGoX );
			
			
			if ( Math.abs( InterpolateNumbers( this.x, 0.001, this.PawnController.DesiredLocToGoX ) ) > 50 ) 
			{   
				if( InterpolateNumbers( this.x, 0.001, this.PawnController.DesiredLocToGoX ) >  this.x  && screen<4) 
				{
					this.ChangeMainTexture('enemyR.png');  
				}
				else if( InterpolateNumbers( this.x, 0.001, this.PawnController.DesiredLocToGoX ) <  this.x  && screen<4)
				{ 
					this.ChangeMainTexture('enemyL.png'); 
				}
				else if( InterpolateNumbers( this.x, 0.001, this.PawnController.DesiredLocToGoX ) >  this.x  && screen>3) 
				{
					this.ChangeMainTexture('enemyRB.png');  
				}
				else if( InterpolateNumbers( this.x, 0.001, this.PawnController.DesiredLocToGoX ) <  this.x  && screen>3) 
				{ 
					this.ChangeMainTexture('enemyLB.png'); 
				}
			} 
			*/
		}
	}	

	//Place it on actor tick 
	ConsiderIfActorWentOutsideLevelByTick()
	{
		
		//place this on vars '1280' 
		if( this.x >= 1280 ) 
		{
			//window.alert("Next level "+this.level+1);
			
			//this.SetActorLocation(0, this.y);
			//GetUniverse().loadNextLevel(0);
			
			//this.level++;	
			
		}
		else if( this.x <= 0 ) 
		{ 

	
			//this.SetActorLocation(1240, this.y);
			
			//if(  Pawn( this.PawnController ) != undefined )
			//{

			//}				
			//{
				//if( BiController ( this.controller ).bIsPlayerControlled == true ) 
				//{ 
					//GetUniverse().loadNextLevel(1);
					//window.alert("Previous level "+this.level-1);
				//}
			//}
			
			//this.level--;		

	    }
		
		
	}


	//to init the attack, basically like the input
	Attack()
	{
		if( this.OffensiveState == "Idle" && this.HandleOfPrepareMinTime == null && this.HandleOfAttackDuration == null ) 
		{
			this.PrepareAttack();
		}
	} 
	
	//to init the prepare attack called on attack()
	PrepareAttack()
	{
		if(this.OffensiveState == "Idle" ) 
		{ 
			if( this.HandleOfPrepareMinTime == null ) 
			{
				if(this.bMovingLeft) 
				{
					this.InternalTexture.setAttribute("src", this.UnleashAttackTexturePrepareLeft);
				}
				else
				{
					this.InternalTexture.setAttribute("src", this.PrepareAttackTexture);	
				}
								
				this.SetOffensiveState("PreparingAttack");		
				this.HandleOfPrepareMinTime = setInterval( this.TimerOfPrepareAttackOver.bind(this), this.MinPrepareAttackDuration);
			}
		} 
	}
	
	TimerOfPrepareAttackOver()
	{
		clearInterval(this.HandleOfPrepareMinTime);	
		this.HandleOfPrepareMinTime = null;
		this.UnleashAttack();
	
	}
	
	
	//to unleash the attack before PrepareAttack()	
	UnleashAttack()
	{
		if(this.OffensiveState == "PreparingAttack") 
		{
			if( this.bHasPressedAttackButtton == false && this.HandleOfPrepareMinTime == null  && this.HandleOfAttackDuration == null) 
			{
				if(this.bMovingLeft) 
				{
					this.InternalTexture.setAttribute("src", this.UnleashAttackTextureLeft);
				}
				else
				{
					this.InternalTexture.setAttribute("src", this.UnleashAttackTexture);	
				}
				
				DoBladeCollisionCheck(this, 100);
				
				this.HandleOfAttackDuration = setInterval( this.FinishAttack.bind(this), this.AttackDuration);
			}
		}
	}	

	FinishAttack()
	{ 
		this.InternalTexture.setAttribute("src", this.mainTexture);	
		
			if(this.bMovingLeft) 
			{
				this.InternalTexture.setAttribute("src", this.IdleTextureLeft);
			}
			else
			{
				this.InternalTexture.setAttribute("src", this.mainTexture);	
			}		
		
		
		this.SetOffensiveState("Idle");	
		clearInterval(this.HandleOfAttackDuration);
		this.HandleOfAttackDuration = null;
	} 

	//Defensive stuff
	ProtectBlockWithShield()
	{		
		if( this.OffensiveState == 'Idle' && this.HandleOfBlockCooldown == null ) 
		{
			//constructor(x, y, floatingtext, textduration, textcolor, textspeed, textlevel) 
			GetUniverse().InstanceGameplayFloatingText(this.x, this.y, "Blocking!", 5.0, 'red', 0.1, this.level);
				
				if(this.bMovingLeft) 
				{
					this.InternalTexture.setAttribute("src", this.BlockingTextureLeft);
				}
				else
				{
					this.InternalTexture.setAttribute("src", this.BlockingTexture);	
				}	
			
			this.HandleOfBlockDuration = setInterval( this.UnProtectBlockWithShield.bind(this), 1000);			
			this.OffensiveState = 'Blocking';
		}		
	}

	//WIP
	UnProtectBlockWithShield()
	{		
	
		if( this.OffensiveState == 'Blocking' ) 
		{	
	
			if(this.bMovingLeft) 
			{
				this.InternalTexture.setAttribute("src", this.IdleTextureLeft);
			}
			else
			{
				this.InternalTexture.setAttribute("src", this.mainTexture);	
			}		
	
			this.OffensiveState = 'Idle';
			this.HandleOfBlockCooldown = setInterval( this.CooldownWithShield.bind(this), 2000);				
			clearInterval(this.HandleOfBlockDuration);
		} 
		

	
	}

	CooldownWithShield()
	{
		clearInterval(this.HandleOfBlockCooldown);		
		this.HandleOfBlockCooldown = null;
	}

	//Desc: Should process the hits after hit test WIP not in use? try to use it! 
	ProcessHits(ActorGettingHit)
	{ 
	
		if(ActorGettingHit.OffensiveState != 'Blocking' && !IsActorFacingOtherActor(ActorGettingHit, this)  )
		{
			ActorGettingHit.TakeDamage(25);
		}
		else
		{ 
			
		}
		
	} 

	//WIP?
	ActorReachedOutSideLevel()
	{ 
	
	}
	
	//Desc: Takes damage
	TakeDamage(DamageToTake)
	{
		console.log("FROM Char taking damage ");
		this.SpawnBlood();
		
	}
	
	//Desc: Spawns blood, it is a pawn to have some properties
	SpawnBlood()
	{
		let LocalBlood;
			
		LocalBlood = GetUniverse().MainCharacter = spawnActor('Blood', this.x, this.y, 2, "BloodParticool.png", "Pawn", 
		0 ,10000, 1, 1, false 
		,"normal", this.level
		);  		
		LocalBlood.bHasCollision = false; //disable collision so it falls through the ground, it is a pawn to have some properties
		
	}

	
	//Desc: goes and dies it is the dead texture
	Die()
	{
		
		
	}
	
	//Desc:  Dissapears from memory 
	Destroy()
	{
		
	}	
	
	
	
	//Sets the actor new location very core function
	SetActorLocation(LocX = 0, LocY = 0)
	{
		this.x = LocX;
		this.y = LocY;		
	}


	
} 

//Controls and can control
class BiController extends Actor 
{

	constructor(name, x, y, team, mainTexture, controlledactor, DesiredLocToGoX, DesiredLocToGoY, bPlayerControlled) 
	{
		super(name, x, y, team, mainTexture);
		this.controlledactor = controlledactor; 
	
		this.DesiredLocToGoX = 0.0; 
		this.DesiredLocToGoY = 0.0;     
		this.bPlayerControlled = bPlayerControlled; //If not it will be AI controlled
		this.bMoving = false; //WIP If this is true shall move by tick same as bRightPressed so far
		this.bGoingRight = false;
		
		setInterval(this.MovementTick.bind(this), 1000); //Use bind this use it for the rest, and posses the monster
		setInterval(this.AttentionTick.bind(this), 1000);
		setInterval(this.DefenseTick.bind(this), 1000);
		setInterval(this.AggresiveTick.bind(this), 1000);
		
	}
  
	posses(possessed)
	{
		this.DesiredLocToGoX = possessed.x;
		this.controlledactor = possessed; 
		possessed.PawnController = this;
	}
   
	SetDesiredLocation(PDesiredLocToGoX, PDesiredLocToGoY)
	{
		this.DesiredLocToGoX = PDesiredLocToGoX; 
		this.DesiredLocToGoY = PDesiredLocToGoY; 
	}  
   
	MovementTick()
	{ 

		//to reach destination consider if desiredLoc is left or right and through that move the character
		if(this.controlledactor != undefined) 
		{
			if(this.bPlayerControlled == false) 
			{

				
				this.PerformRoamToRandomLocation();
				
			}			
		}

	}  
   
	AttentionTick()
	{ 


	}  
  
	DefenseTick()
	{ 
		//to reach destination consider if desiredLoc is left or right and through that move the character
		if(this.controlledactor != undefined) 
		{
			if(this.bPlayerControlled == false) 
			{
				this.PerformBlock()
			}
			
		}
	} 
  
	AggresiveTick()
	{ 
		//to reach destination consider if desiredLoc is left or right and through that move the character
		if(this.controlledactor != undefined) 
		{
			if(this.bPlayerControlled == false) 
			{
				this.PerformAttack();
			}			
		}

	} 
  
	PerformRoamToRandomLocation()
	{ 
	let RandBoolMoveRight;
	
	
		RandBoolMoveRight = GetRandomBoolean();
		
		this.controlledactor.bMoving = true; //WIP If this is true shall move by tick same as bRightPressed so far
		this.controlledactor.bGoingRight = RandBoolMoveRight;
		this.controlledactor.ChangeDirection(!RandBoolMoveRight);
		setTimeout( this.StopMoving.bind(this), GetRandomFloat(50, 100, 3));		
	}
	
	PerformAttack()
	{ 
		this.controlledactor.PrepareAttack();	
	}
	
	PerformBlock()
	{ 
		this.controlledactor.ProtectBlockWithShield();	
	}
		
	StopMoving()
	{
		this.controlledactor.bMoving = false; //WIP If this is true shall move by tick same as bRightPressed so far
		this.controlledactor.bGoingRight = false;		
	}
  
	
  
  
}


class Pawn extends Actor 
{
	constructor(name, x, y, team, mainTexture, PawnController, Screen, actorClass, collisionSizeMinX1, collisionSizeMinY1, collisionSizeMaxX1, collisionSizeMaxY1, DrawSizeX, DrawSizeY, ClippingImageSizeX, ClippingImageSizeY, level ) 
	{
		super(name, x, y, team, mainTexture, "some interal texture", "Some health", "Some actor state", collisionSizeMinX1, collisionSizeMinY1, collisionSizeMaxX1, collisionSizeMaxY1, DrawSizeX, DrawSizeY, ClippingImageSizeX, ClippingImageSizeY, level ); 
//constructor(name, x, y, team, mainTexture, InternalTexture, ActorHealth, ActorState, collisionSizeMinX1, collisionSizeMinY1, collisionSizeMaxX1, collisionSizeMaxY1, DrawSizeX, DrawSizeY) 
	
		this.collisionSizeMinX1 = -125; //the collision size box
		this.collisionSizeMinY1 = -100; //the collision size box
		this.collisionSizeMaxX1 = 125; //the collision size box
		this.collisionSizeMaxY1 = 125; //the collision size box		
		this.DrawSizeX = 100; //the collision size box		
		this.DrawSizeY = 128; //the collision size box	
		this.ClippingImageSizeX = 128; 
		this.ClippingImageSizeY = 128;


		
	}



	ActorFeltThroughWorld()
	{ 
		if(this.ActorState != "Dead") 
		{ 
			this.ActorDie();
		}
	}
	

	ActorOutsideWorld()
	{ 
		if(this.ActorState != "Dead") 
		{ 
			this.DestroySelf();
		}	
	}	
	
	
	//Place it on actor tick 
	ConsiderIfActorWentOutsideLevelByTick()
	{
		

		
		//place this on vars '1280' 
		if( this.x >= 1280 ) 
		{
			this.SetActorLocation(15, this.y);			

			
			if(  this.PawnController != undefined  )
			{ 
		
				if( this.PawnController.bPlayerControlled == true ) 
				{
					GetUniverse().loadNextLevel(0);
					window.alert("Next level ");					
				}

			}				

			this.level++;		
			
		}
		else if( this.x <= 0 ) 
		{ 
			this.SetActorLocation(1235, this.y);
			
			if(  this.PawnController != undefined  )
			{ 

				if( this.PawnController.bPlayerControlled == true ) 
				{
					GetUniverse().loadNextLevel(1);
					window.alert("Previous level ");					
				}

			}				
			

			this.level--;		

	    }
		
		
	}
	
	


}

function spawnActor(name, x,y, team, 
mainTexture, actorClass, 
ControlledActor, LifeTimeOfActor, ActorInitialSpeedX, ActorInitialSpeedY, bIsPlayerControlled, 
state, level )
{




	if( actorClass == "Universe" )
	{	

	    return new Universe( name, state, level  ); 		
	}

    if( actorClass == "Actor")
	{
			//constructor(name, x, y, team, mainTexture, InternalTexture, ActorHealth, ActorState, collisionSizeMinX1, collisionSizeMinY1, collisionSizeMaxX1, collisionSizeMaxY1, DrawSizeX, DrawSizeY) 
	    GetUniverse().actorsIngame.push(new Actor(name, x, y, team, mainTexture, "InternalTexture", "Somehealth", state, level )); 
	}

    if( actorClass == "BiController")   //constructor(name, x, y, team, mainTexture, controlledactor, DesiredLocToGoX, DesiredLocToGoY, bPlayerControlled) 
	{
	    GetUniverse().actorsIngame.push(new BiController(name, x, y, team, mainTexture, screen, 0, 0,  bIsPlayerControlled, level  )); 
	}

	if( actorClass == "Pawn" )
	{	
	    GetUniverse().actorsIngame.push(new Pawn(name, x, y, team, mainTexture, "some controller" , Screen, actorClass,    level    ) );		
	}
	
		
	
//constructor(name, x, y, team, mainTexture, PawnController, Screen, actorClass, collisionSizeMinX1, collisionSizeMinY1, collisionSizeMaxX1, collisionSizeMaxY1, DrawSizeX, DrawSizeY)
	return GetUniverse().actorsIngame[GetUniverse().actorsIngame.length-1]; 	
}


function BeginPlay() 
{
	window.requestAnimationFrame(draw);	
       
	

	
    if (document.images) 
    { 
	
		//Examples of assigning images to stuff SOme references delete this*
		wall.setAttribute("src", "DesolatedHut.png");
		gladiatorTest.setAttribute("src", "Mullius.png");
		BGImage.setAttribute("src", "Bacrkound.png");
		TestPlatform.setAttribute("src", "Platform.png");
		
		//Spawn the GameInfo the universe and such 
		ActualUniverse = spawnActor('UniverseInfo', 50, 50, 2, 
		"Platform.png", "Universe",0 ,10000, 1, 1, 
		false
		,"normal", 0 
		);   //Platform 5 on the left to test collision				
		
		
		GetUniverse().MainCharacter = spawnActor('MulliusMainChar', 50, 450, 2, "MulliusShieldAndSwordIdle.png", "Pawn", 
		0 ,10000, 1, 1, false
		,"normal", 0
		);   //Mullius main character, player controlled
		


		EnemyCharacterStageOne = spawnActor('EnemeyStageOneNumberOne', 300, 450, 2, "GladiatorLenemieRed.png", "Pawn", 
		0 ,10000, 1, 1, false
		,"normal", 0
		);   //Enemy to kill 1
		
		//Add the draw size and such to it
		
		EnemyCharacterStageOne.DrawSizeX = 115;
		EnemyCharacterStageOne.DrawSizeY = 115;			
		EnemyCharacterStageOne.ClippingImageSizeX = 128.0;
		EnemyCharacterStageOne.ClippingImageSizeY = 128.0;		
		EnemyCharacterStageOne.YOffset = -10;		
		/*
		this.collisionSizeMinX1 = -125; //the collision size box
		this.collisionSizeMinY1 = -200; //the collision size box
		this.collisionSizeMaxX1 = 125; //the collision size box
		this.collisionSizeMaxY1 = 125; //the collision size box	
		this.DrawSizeX = 256; //the draw size
		this.DrawSizeY = 64; //the draw size	
		this.ClippingImageSizeX = 885.0;
		this.ClippingImageSizeY = 100.0;
		*/
		
		//Controllers AI and player controller
		
			//PlayerController
			
		GetUniverse().MainBiController = spawnActor('PlayerBiController', 25, 0, 2, "Mullius.png", "BiController",
		GetUniverse().MainCharacter,100000,0,0,true );   //Controller bi so both for player and others

		GetUniverse().MainBiController.posses(GetUniverse().MainCharacter); //Posses by player controller					//Collisions -X -Y X Y 
	
		//GetUniverse().MainBiController
		
			//AIController
		AIBiController1 = spawnActor('AIBiController1', 25, 0, 2, "Mullius.png", "BiController",
		EnemyCharacterStageOne,100000,0,0,false );   //Controller bi so both for player and others
	
		//Textures
		//The idle one is already included
		EnemyCharacterStageOne.PrepareAttackTexture = "GladiatorLenemieRedPrepareAttack.png"; //Prepare here
		EnemyCharacterStageOne.UnleashAttackTexture = "GladiatorLenemieRedUnleashAttack.png";
		EnemyCharacterStageOne.BlockingTexture = "GladiatorLenemieRedBlockWithShield.png";	//WIP	
		
		//Left textrues
		EnemyCharacterStageOne.IdleTextureLeft = "GladiatorLenemieRedLeft.png";	
		EnemyCharacterStageOne.UnleashAttackTextureLeft = "GladiatorLenemieRedUnleashAttackLeft.png";			
		EnemyCharacterStageOne.UnleashAttackTexturePrepareLeft = "GladiatorLenemieRedPrepareAttackLeft.png";
		EnemyCharacterStageOne.BlockingTextureLeft = "GladiatorLenemieRedBlockWithShieldLeft.png"	//WIP	
			
		

		
		AIBiController1.posses(EnemyCharacterStageOne) //Posses by player controller					//Collisions -X -Y X Y 
		AIBiController1.state = "Roam";						

		
		
				
		
		
		//AIControllers
		
		//...
		
		
		
		//Next level 1
		spawnActor('Plataforma1', 50, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 0 );   //Platform 2	
		
		spawnActor('Plataforma2', 300, 600, 2, "Platform.png", "Actor",
		0 ,10000, 1, 1, false,
		 "normal", 0 );   //Platform 2	
		
		spawnActor('Plataforma3', 400, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 0 );   //Platform 3
		
		spawnActor('Plataforma4', 700, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 0 );   //Platform 4		
		
		spawnActor('Plataforma5', -175, 600, 2, "Platform.png", "Actor",
		0 ,10000, 1, 1, false, 
		 "normal", 0 );   //Platform 5 on the left to test collision		
		
		//spawnActor('Plataforma6', 900, 600, 2, "Platform.png", "Actor"
		//,0 ,10000, 1, 1, false, 
		// "normal", 0 );   //Platform 4		
				
		spawnActor('Plataforma7', 1100, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 0 );   //Platform 4		
				
		spawnActor('Plataforma8Elevated', 900, 525, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 0 );   //Platform 4		
						
		
		
		//Next level 2
		spawnActor('Plataforma1Level1', 0, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 1 );   //Platform 1 level 2	
	
		spawnActor('Plataforma2Level2', 200, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 1 );   //Platform 1 level 2			
		
		spawnActor('Plataforma2Level2', 400, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 1 );   //Platform 1 level 2			
				
		spawnActor('Plataforma2Level3', 600, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 1 );   //Platform 1 level 2			
						
		spawnActor('Plataforma2Level4', 800, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 1 );   //Platform 1 level 2			

		spawnActor('Plataforma2Level5', 1000, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 1 );   //Platform 1 level 2			
										
		spawnActor('Plataforma2Level6', 1200, 600, 2, "Platform.png", "Actor"
		,0 ,10000, 1, 1, false, 
		 "normal", 1 );   //Platform 1 level 2			
			
	
		EnemyCharacterStageOne = spawnActor('EnemeyStage2', 1000, 450, 2, "GladiatorLenemieWhite.png", "Pawn", 
		0 ,10000, 1, 1, false,
		"normal", 1
		);   //Enemy to kill 1		
		
		
		//function spawnActor(name, x,y, team, mainTexture, actorClass, ControlledActor, LifeTimeOfActor, ActorInitialSpeedX, ActorInitialSpeedY, bIsPlayerControlled, pcollisionSizeMinX1, pcollisionSizeMinY1, pcollisionSizeMaxX1, pcollisionSizeMaxY1, pDrawSizeX, pDrawSizeY, pClippingImageSizeX, pClippingImageSizeY)

		//spawnActor('Plataforma4Elevated', 400, 450, 2, "Platform.png", "Actor",0 ,10000, 1, 1, false, -150.0 ,-200.0, 150.0, 200.0, 256.0, 64.0, 885.0, 100.0 );   //Platform 3		
				
		
		//spawnActor('Plataforma', 75, 200, 2, "Platform.png", "Actor",0 ,10000, 1, 1, false, -100.0 ,-100.0, 100.0, 100.0, 256.0, 128.0, 885.0, 100.0 );   //Platform 1	
		//spawnActor('Plataforma', 100, 200, 2, "Platform.png", "Actor",0 ,10000, 1, 1, false, -100.0 ,-100.0, 100.0, 100.0, 256.0, 128.0, 885.0, 100.0 );   //Platform 1			
	}
}                      

	
function addLoadEvent(func) 
{
	
		
	var oldonload = window.onload;
	if (typeof window.onload != 'function') 
        {
		window.onload = func;
	    } 
    else 
        {
    	window.onload = function() 
            {
			if (oldonload) 
                {
				oldonload();
			    }
			func();
		    }
    	}
    }
// PRELOAD IMAGES
addLoadEvent(BeginPlay);
//VARS
let deltaTime = 0;
let lastTimestamp = 0;
const perfectFrameTime = 1000 / 60;


// CANVAS
var canvas = document.getElementById('canvas');

if (canvas.getContext) 
{
	var ctx = canvas.getContext('2d');
}
// KEYBOARD



document.onkeydown = checkKeyDown;
function checkKeyDown(e) //Interpolating with no purpose!
    {
		//left walk key <-
		if (e.keyCode == '37' )  
        { 
			GetUniverse().MainBiController.controlledactor.bMoving = true;
			GetUniverse().MainBiController.controlledactor.bGoingRight = false;	
			GetUniverse().MainBiController.controlledactor.ChangeDirection(true);
			//MainBiController.controlledactor.x = InterpolateNumbers( MainBiController.controlledactor.x ,  1, MainBiController.controlledactor.x - 10 );
        }
		
		//right walk key ->
		if (e.keyCode == '39' ) 
        {   

			GetUniverse().MainBiController.controlledactor.bMoving = true;
			GetUniverse().MainBiController.controlledactor.bGoingRight = true;
			GetUniverse().MainBiController.controlledactor.ChangeDirection(false);		
			//MainBiController.controlledactor.x = InterpolateNumbers( MainBiController.controlledactor.x ,  1, MainBiController.controlledactor.x + 10 );		
        }
		
		//Left Walk A key
		if (e.keyCode == '65' )  
        {  
			GetUniverse().MainBiController.controlledactor.bMoving = true;
			GetUniverse().MainBiController.controlledactor.bGoingRight = false;	
			GetUniverse().MainBiController.controlledactor.ChangeDirection(true);
			//MainBiController.controlledactor.x = InterpolateNumbers( MainBiController.controlledactor.x ,  1, MainBiController.controlledactor.x - 10 );	
        }	
		
		//Right Walk D key		
		if (e.keyCode == '68' )  
        {  
			GetUniverse().MainBiController.controlledactor.bMoving = true;
			GetUniverse().MainBiController.controlledactor.bGoingRight = true;		
			GetUniverse().MainBiController.controlledactor.ChangeDirection(false);			
			//MainBiController.controlledactor.x = InterpolateNumbers( MainBiController.controlledactor.x ,  1, MainBiController.controlledactor.x + 10 );
        }				
	
		//Spacebar jump		
		if (e.keyCode == '32' )  
        { 
			GetUniverse().MainBiController.bMoving = true;
			GetUniverse().MainBiController.controlledactor.BeginJump();
        }	

		//Attack Key F		
		if (e.keyCode == '70' )  
        { 
			GetUniverse().MainBiController.controlledactor.Attack();
			GetUniverse().MainBiController.controlledactor.bHasPressedAttackButtton = true;
        }		
 
		//Attack Key B		
		if (e.keyCode == '66' )  
        { 
			GetUniverse().MainBiController.controlledactor.ProtectBlockWithShield();
        }		
  
 
    
    }
document.onkeyup = checkKeyUp;
//ON RELASE
function checkKeyUp(e) 
{
		if (e.keyCode == '37') //left cursor
        {
			GetUniverse().MainBiController.controlledactor.bMoving = false;
			GetUniverse().MainBiController.controlledactor.bGoingRight = false;	

			//MainBiController.controlledactor.x = InterpolateNumbers( MainBiController.controlledactor.x ,  1, MainBiController.controlledactor.x - 10 );	
		
        }
		if (e.keyCode == '39') //right cursor
        {   
 			GetUniverse().MainBiController.controlledactor.bMoving = false;
			GetUniverse().MainBiController.controlledactor.bGoingRight = true;			
			//MainBiController.controlledactor.x = InterpolateNumbers( MainBiController.controlledactor.x ,  1, MainBiController.controlledactor.x + 10 );
        }
		
		//Left Walk A key STOP 
		if (e.keyCode == '65' )  
        {  
			GetUniverse().MainBiController.controlledactor.bMoving = false;
			GetUniverse().MainBiController.controlledactor.bGoingRight = false;	
			//MainBiController.controlledactor.x = InterpolateNumbers( MainBiController.controlledactor.x ,  1, MainBiController.controlledactor.x - 10 );	
        }	
		
		//Right Walk D key STOP 	
		if (e.keyCode == '68' )  
        {  
			GetUniverse().MainBiController.controlledactor.bMoving = false;
			GetUniverse().MainBiController.controlledactor.bGoingRight = true;			
			//MainBiController.controlledactor.x = InterpolateNumbers( MainBiController.controlledactor.x ,  1, MainBiController.controlledactor.x + 10 );
        }				
			
		//Attack Key F		
		if (e.keyCode == '70' )  
        { 
			GetUniverse().MainBiController.controlledactor.bHasPressedAttackButtton = false;			
			GetUniverse().MainBiController.controlledactor.UnleashAttack();
        }		
		
		
			//Attack Key B		
		if (e.keyCode == '66' )  
        { 

        }		
  
 	
		
		
		
}
	

	
//Desc: Aqusta funcio savisa tot el temps
function draw(timestamp) 
{	
    requestAnimationFrame(draw);
    deltaTime = (timestamp - lastTimestamp) / perfectFrameTime;


		
    //clean canvas screen
    canvas.width=canvas.width;
    //screen
    ctx.beginPath();
	
	ctx.drawImage(BGImage,0,0,1,1,0,0,1280,720);	 //this is the backround Occupy whole screen
	
	//Debug style for the rectangle showing upfroint position
	
	if( GetUniverse().bDrawDebug ) 
	{
		ctx.beginPath();
		ctx.rect(GetUniverse().MainBiController.controlledactor.x+25, GetUniverse().MainBiController.controlledactor.y-30, 10, 10);
		ctx.strokeStyle = "blue";	
		ctx.stroke();	
	
		ctx.beginPath();	
		ctx.rect(GetUniverse().MainBiController.controlledactor.x-25, GetUniverse().MainBiController.controlledactor.y-30, 10, 10);	
		ctx.strokeStyle = "red";	
		ctx.stroke();
			
	}
		ctx.fillStyle = "green";	
		ctx.font = "30px Arial";
		ctx.fillText("Hello world", 200, 200);

		GetUniverse().actorsIngame.forEach(DrawActors);
		
		function DrawActors(value, index, array) 
		{		
			if(value.constructor.name != "Universe" && value.constructor.name != "BiController") //value.level == ActualUniverse.level
			{		
				if( value.level == ActualUniverse.level ) //value.level == ActualUniverse.level
				{
					//ctx.fillStyle = 'blue'; //It does not give color to a image
					ctx.drawImage(value.InternalTexture,0,0,value.ClippingImageSizeX,value.ClippingImageSizeY,value.x - value.XOffset, value.y - value.YOffset, value.DrawSizeX,value.DrawSizeY);
					value.ActorTick(timestamp);
				}
			}
        }		
	
	
		GetUniverse().floatingtexts.forEach(DrawFoatingTextes);
		
		function DrawFoatingTextes(value, index, array)
		{	
				//if( value.level == ActualUniverse.level ) //value.level == ActualUniverse.level
				//{
					ctx.fillStyle = value.textcolor; //It does not give color to a image
					ctx.font = "30px Arial";
					ctx.fillText(value.floatingtext, value.x, value.y);
					//value.ActorTick(timestamp);
				//}			
		}
			
	lastTimestamp = timestamp;	
} //End draw
	
	
//Desc: Neongho:Global mathemathical function
function DoesThisCollide( originX, originY, SizeXMin1, SizeYMin1, SizeXMax1, SizeYMax1  ) 	
{

	if( originX < SizeXMax1 ) //First X
	{ 
		if( originX > SizeXMin1 ) 
		{ 
			if( originY < SizeYMax1) //Then Y 
			{
				if(  originY > SizeYMin1 ) 
				{									
					return true;
				} 
			}
		} 	
	} 

	return false;
}

function DoBladeCollisionCheck(ActorSwinging, DistanceOfBlade)
{
	let AllActorsToBladeCheck = GetAllActorsIngame();


		AllActorsToBladeCheck.forEach(CheckIfItHits);
		
		function CheckIfItHits(value, index, array) 	
		{
			ReturnDistanceFromTwoActors(ActorSwinging, value);
	
		
			
			if( IsActorFacingOtherActor(ActorSwinging, value) && ReturnDistanceFromTwoActors(ActorSwinging, value) < DistanceOfBlade && value.constructor.name == "Pawn") 
			{ 
				if( value != ActorSwinging ) 
				{
					ActorSwinging.ProcessHits(value);
				}
			}
		}
		
}

function ReturnDistanceFromTwoActors(Actor1, Actor2)
{
	
	return ReturnDistanceFromTwoPoints( Actor1.x, Actor2.x, Actor1.y, Actor2.y  );
	
}

function ReturnDistanceFromTwoPoints(Vec1x, Vec1y, Vec2x, Vec2y)
{
	return Math.abs( ( ( Vec1x - Vec2x ) - ( Vec1y - Vec2y ) ) );
	
}

function IsActorFacingOtherActor(Actor1, Actor2)
{

	if( ( Actor1.bMovingLeft && ReturnDirectionActorsDegrees(Actor1, Actor2) >= 0 ) || ( !Actor1.bMovingLeft && ReturnDirectionActorsDegrees(Actor1, Actor2) <= 0 ) )
	{
		return true;
	}
	else
	{ 
		return false;
	}




	
}



//Desc: Neongho: To then step on it or so use outer or from 180 to -180 if happends to be exactly 0 or so on the feet then step on it
function ReturnDirectionActors(Actor1, Actor2)
{							//Change the value that means that this is Up or down, later on use actor height or the collision
	return Actor1.y - ( Actor2.y - 75 );
}

//Desc: This will return in non degrees the angle, WIP work on progress
//Good only to distinct from left to right
function ReturnDirectionActorsDegrees(Actor1, Actor2)
{	
	let DotProductOfTwo;
	let Determinant;
		
    //First dot product 
    DotProductOfTwo = Actor1.x * Actor2.x + Actor1.y * Actor2.y;
    //First determinant idk what it is exactly 
    Determinant = Actor1.x * Actor2.y - Actor1.y * Actor2.x;
    
	//Change the value that means that this is Up or down, later on use actor height or the collision

	return Math.atan2(Determinant,  DotProductOfTwo);
}

//Desc: Neongho: translates a number into the direction which returns true or false just left or just right
function TranslateNumToUpOrDown(DirNum)
{
	return DirNum < 0;	
}

//Desc: Neongho: Interpolate does not work so well 
function InterpolateNumbers(ActualNumber, InterpSpeed, FinalNumber )
{
    return Math.round(ActualNumber + ( FinalNumber - ActualNumber ) * InterpSpeed );
}

function GetUniverse()
{
	return ActualUniverse;	
}


//Try to send the player controller into universe
function GetPlayerController()
{
	return GetUniverse().MainBiController;	
}

//Try to send the player controller into universe
function GetPlayerPawn()
{
	return GetUniverse().MainCharacter;	
}


function GetClosestActorToActor(ActorSelf)
{
	let ActorsToIterate = [];

	ActorsToIterate = GetAllActorsIngame();	
}

function GetAllActorsIngame()
{
	return GetUniverse().actorsIngame;	
}

function GetRandomBoolean()
{
	let booleanValue;
	
	if ( Math.random() > 0.5 )
	{
	  booleanValue = true;
	} else 
	{
	  booleanValue = false;  
	}	
	
	return booleanValue;
}


function GetRandomFloat(min, max, decimals)
{
	const str = (Math.random() * (max - min) + min).toFixed(decimals);

	return parseFloat(str);
}


</script>



</html>
